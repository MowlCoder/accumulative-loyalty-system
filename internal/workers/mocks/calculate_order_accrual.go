// Code generated by MockGen. DO NOT EDIT.
// Source: calculate_order_accrual.go
//
// Generated by this command:
//
//	mockgen -source=calculate_order_accrual.go -destination=./mocks/calculate_order_accrual.go -package=repomock
//
// Package repomock is a generated GoMock package.
package repomock

import (
	context "context"
	reflect "reflect"

	domain "github.com/MowlCoder/accumulative-loyalty-system/internal/domain"
	gomock "go.uber.org/mock/gomock"
)

// MockregisteredOrdersRepository is a mock of registeredOrdersRepository interface.
type MockregisteredOrdersRepository struct {
	ctrl     *gomock.Controller
	recorder *MockregisteredOrdersRepositoryMockRecorder
}

// MockregisteredOrdersRepositoryMockRecorder is the mock recorder for MockregisteredOrdersRepository.
type MockregisteredOrdersRepositoryMockRecorder struct {
	mock *MockregisteredOrdersRepository
}

// NewMockregisteredOrdersRepository creates a new mock instance.
func NewMockregisteredOrdersRepository(ctrl *gomock.Controller) *MockregisteredOrdersRepository {
	mock := &MockregisteredOrdersRepository{ctrl: ctrl}
	mock.recorder = &MockregisteredOrdersRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockregisteredOrdersRepository) EXPECT() *MockregisteredOrdersRepositoryMockRecorder {
	return m.recorder
}

// ChangeOrdersStatus mocks base method.
func (m *MockregisteredOrdersRepository) ChangeOrdersStatus(ctx context.Context, orderIDs []string, status string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ChangeOrdersStatus", ctx, orderIDs, status)
	ret0, _ := ret[0].(error)
	return ret0
}

// ChangeOrdersStatus indicates an expected call of ChangeOrdersStatus.
func (mr *MockregisteredOrdersRepositoryMockRecorder) ChangeOrdersStatus(ctx, orderIDs, status any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ChangeOrdersStatus", reflect.TypeOf((*MockregisteredOrdersRepository)(nil).ChangeOrdersStatus), ctx, orderIDs, status)
}

// GetOrderGoods mocks base method.
func (m *MockregisteredOrdersRepository) GetOrderGoods(ctx context.Context, orderID string) ([]domain.OrderGood, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetOrderGoods", ctx, orderID)
	ret0, _ := ret[0].([]domain.OrderGood)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetOrderGoods indicates an expected call of GetOrderGoods.
func (mr *MockregisteredOrdersRepositoryMockRecorder) GetOrderGoods(ctx, orderID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetOrderGoods", reflect.TypeOf((*MockregisteredOrdersRepository)(nil).GetOrderGoods), ctx, orderID)
}

// SetCalculatedOrderAccrual mocks base method.
func (m *MockregisteredOrdersRepository) SetCalculatedOrderAccrual(ctx context.Context, orderID string, accrual float64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetCalculatedOrderAccrual", ctx, orderID, accrual)
	ret0, _ := ret[0].(error)
	return ret0
}

// SetCalculatedOrderAccrual indicates an expected call of SetCalculatedOrderAccrual.
func (mr *MockregisteredOrdersRepositoryMockRecorder) SetCalculatedOrderAccrual(ctx, orderID, accrual any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetCalculatedOrderAccrual", reflect.TypeOf((*MockregisteredOrdersRepository)(nil).SetCalculatedOrderAccrual), ctx, orderID, accrual)
}

// TakeOrdersForProcessing mocks base method.
func (m *MockregisteredOrdersRepository) TakeOrdersForProcessing(ctx context.Context, limit int) ([]domain.RegisteredOrder, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TakeOrdersForProcessing", ctx, limit)
	ret0, _ := ret[0].([]domain.RegisteredOrder)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TakeOrdersForProcessing indicates an expected call of TakeOrdersForProcessing.
func (mr *MockregisteredOrdersRepositoryMockRecorder) TakeOrdersForProcessing(ctx, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TakeOrdersForProcessing", reflect.TypeOf((*MockregisteredOrdersRepository)(nil).TakeOrdersForProcessing), ctx, limit)
}

// MockgoodRewardRepository is a mock of goodRewardRepository interface.
type MockgoodRewardRepository struct {
	ctrl     *gomock.Controller
	recorder *MockgoodRewardRepositoryMockRecorder
}

// MockgoodRewardRepositoryMockRecorder is the mock recorder for MockgoodRewardRepository.
type MockgoodRewardRepositoryMockRecorder struct {
	mock *MockgoodRewardRepository
}

// NewMockgoodRewardRepository creates a new mock instance.
func NewMockgoodRewardRepository(ctrl *gomock.Controller) *MockgoodRewardRepository {
	mock := &MockgoodRewardRepository{ctrl: ctrl}
	mock.recorder = &MockgoodRewardRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockgoodRewardRepository) EXPECT() *MockgoodRewardRepositoryMockRecorder {
	return m.recorder
}

// GetRewardsWithMatches mocks base method.
func (m *MockgoodRewardRepository) GetRewardsWithMatches(ctx context.Context, descriptions []string) ([]domain.GoodReward, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetRewardsWithMatches", ctx, descriptions)
	ret0, _ := ret[0].([]domain.GoodReward)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetRewardsWithMatches indicates an expected call of GetRewardsWithMatches.
func (mr *MockgoodRewardRepositoryMockRecorder) GetRewardsWithMatches(ctx, descriptions any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetRewardsWithMatches", reflect.TypeOf((*MockgoodRewardRepository)(nil).GetRewardsWithMatches), ctx, descriptions)
}
